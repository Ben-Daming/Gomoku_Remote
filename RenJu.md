# 禁手规则开发日志
## 2025.11.28 01:38
五子棋程序其他部分是dirty work，没有含金量，困难的点只有两个：
- 判断禁手规则
- 写AI

开发完框架后，这两个部分创造两个独立的分支，预期长期开发。写日志怕我自己忘了具体实现。

AI的挑战性远大于禁手，本着先易后难的原则，先开发禁手判断。（`rules.h/c`)

**开发禁手预期**：由于之后的AI搜索大概率高强度使用禁手判断，因此该流程必须尽量做到高效，用一大堆if/else堆逻辑是行不通的。

**目前的实现方案**：

采用了 **滑动窗口** 和 **编码** 的方式进行棋型匹配，尽量优化性能

#### 1. 棋型编码
为了避免大量的 `if-else` 逐格判断，将棋盘上的局部状态编码为整数。
- **基数**：使用 3 的幂次方 (`base[i] = 3^i`)。
- **编码规则**：在滑动窗口中，空位贡献 0，黑子贡献 $1 \times 3^i$。遇到白子或边界则截断或视为无效。
- **模式匹配**：计算出的 `value` 直接与预定义的常量（如 `PATTERN_HUO_THREE_1`）进行比较。

例如，棋型 `●●_●●` (11011) 被编码为：
$1\cdot3^0 + 1\cdot3^1 + 0\cdot3^2 + 1\cdot3^3 + 1\cdot3^4 = 1 + 3 + 0 + 27 + 81 = 112$

#### 2. 禁手检测流程 (`isForbidden`)
函数 `isForbidden` 模拟在 `(row, col)` 落子（黑棋），然后依次检查：

1.  **长连 (Overline)**：
    - 优先级最高。
    - 直接统计四个方向的连续黑子数，若 > 5 则判定为长连禁手。

2.  **四四禁手 (4-4)**：
    - 统计四个方向上的 **活四** 和 **冲四** 的总数。
    - `isHuoFour`：检测连续的四（如 `_●●●●_` 或 `○●●●●_`）。
    - `isChongFour`：检测跳跃型的冲四（如 `●●_●●`）。
    - 若总数 $\ge 2$，判定为四四禁手。
    - **code时容易搞混的一个点**：形成五连的四不计入禁手（五连即胜），但在 `isForbidden` 调用前通常会先检查是否获胜。

3.  **三三禁手 (3-3)**：
    - 统计四个方向上的 **真活三** 数量。
    - `isHuoThree`：检测潜在的活三形状。
    - **递归验证 (关键)**：
        - 对于每一个形状上的“活三”，找到其能够发展成“活四”的关键点 (`key_i, key_j`)。
        - **递归调用** `isForbidden(key_i, key_j)`。
        - 如果关键点是禁手点，则该“三”被视为“假三”（眠三），**不计入**三三禁手统计。
        - 只有当关键点是合法落子点时，才算作一个有效的“活三”。
    - 若有效活三数 $\ge 2$，判定为三三禁手。

#### 3. 关键函数
- `isHuoFour`: 处理连续型的四，判断两端是否被堵死。
- `isChongFour`: 处理中间有空位的四，利用三进制哈希快速识别 `11011`, `10111`, `11101` 等模式。
- `isHuoThree`: 处理活三，同样利用哈希识别 `011100`, `010110` 等模式，并包含递归逻辑。

#### 4. 性能考量
- 这种基于整数哈希的匹配方式比字符串匹配快得多。
- 递归检查也不会造成死循环，因为每次递归前都填充了原来的那个点，一开始搞蒙了。
- 一个问题：一开始写的时候参考github上的代码，跟风用了三进制哈希表，但是针对黑棋的判断似乎压根用不上三进制，只需要管黑棋的1和空位的0就行了。下次改成位运算应该能更快。

## 2025.11.28 02:34
#### 新增内容
- 开发了一个debug模式，专门测试禁手，测试效率提高了很多。效果图如下：
![三三禁手1](test1.png)
![禁手2](test2.png)
第二张图带来了意外收获，下在H10时黑棋L10处未解禁，因为我当时觉得没必要给冲四加长连判断，但是实践告诉我我错了。所以我又回去给四加上了眠四判断。